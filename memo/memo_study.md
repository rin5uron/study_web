# 📝 学習メモ

## 📋 目次
- [メモの書き方](#-メモの書き方)
- [環境設定](#環境設定)
- [WEB用語](#web用語)
  - [マークダウン記法](#マークダウン記法markdown)
- [CSS関連](#css関連)
  - [ホバー効果とカーソルプロパティ](#ホバー効果とカーソルプロパティ)
  - [marginプロパティ](#marginプロパティの詳細)
  - [max-widthプロパティ](#max-widthプロパティの詳細)
  - [overflow: hidden](#overflow-hidden)
  - [リセットスタイル](#リセットスタイル)
  - [フォントフォールバック](#フォントフォールバック)
  - [Flexboxレイアウト](#flexboxレイアウト)
  - [displayプロパティ](#displayプロパティの詳細)
  - [align-itemsプロパティ](#align-itemsプロパティの詳細)
  - [よく使われるFlexboxの組み合わせパターン](#よく使われるflexboxの組み合わせパターン)
  - [CSSの優先順位](#cssの優先順位)
  - [パディング指定](#パディング指定)
  - [width設定のポイント](#width設定のポイント)
  - [CSSセレクタの種類](#cssセレクタの種類)
  - [要素セレクタとクラスセレクタの違い](#要素セレクタとクラスセレクタの違い)
  - [内部CSSの配置](#内部cssの配置)
  - [インラインスタイル](#インラインスタイル)
- [JavaScript関連](#javascript関連)
  - [アコーディオンメニューの開閉制御](#アコーディオンメニューの開閉制御)
  - [イベント駆動型プログラミング](#イベント駆動型プログラミング)
- [サジェスト機能の使い方](#サジェスト機能の使い方)
  - [基本的な使い方](#基本的な使い方)
  - [手動で候補を表示する方法](#手動で候補を表示する方法)
- [HTMLのショートカット入力](#htmlのショートカット入力)
  - [Emmetショートカット](#emmetショートカット)
  - [index.htmlについて](#indexhtmlについて)
- [Git・GitHub関連](#gitgithub関連)
  - [基本用語](#基本用語)
  - [ステージングについて](#ステージングについて)
- [JavaScriptファイルの読み込み方法](#javascriptファイルの読み込み方法)
  - [HTMLからJavaScriptファイルを読み込む基本](#htmlからjavascriptファイルを読み込む基本)
  - [読み込み位置による違い](#読み込み位置による違い)
  - [属性オプション](#属性オプション)
  - [相対パスと絶対パス](#相対パスと絶対パス)

## 📌 メモの書き方
- 日付と内容を明確に記載
- 必要に応じてカテゴリ分けを行う
- 重要なポイントは強調して記載

## 【環境設定】
- 使用PC：MacBook Air
- OS：macOS
- 主要アプリケーション：VSCode, Chrome

## WEB用語

### マークダウン記法（Markdown）
テキストを構造化するための軽量マークアップ言語。主な記法：
- `#`：見出し（# 大見出し、## 中見出し）
- `-` or `*`：箇条書きリスト
- `1.`, `2.`：番号付きリスト
- `**太字**`：**太字**表示
- `*斜体*`：*斜体*表示
- `` `コード` ``：`コード`表示
- `[リンク](URL)`：ハイパーリンク
- `![代替テキスト](画像URL)`：画像挿入

GitHubやNotion等で広く使用される。HTMLより簡潔に記述可能。

## 【CSS関連】

### CSS基本プロパティと使い方

#### ホバー効果とカーソルプロパティ

**ホバー（:hover）疑似クラス**

ホバーとは、マウスカーソルを要素の上に置いた状態のことです。CSSでは`:hover`疑似クラスを使用して、この状態の時のスタイルを指定できます。

**基本的な使い方:**
```css
.button:hover {
  background-color: blue;  /* ホバー時は背景色が青に変わる */
}
```

#### CSS擬似要素（::before, ::after）

擬似要素とは「HTMLには書いていないけど、CSSだけで追加できる架空の要素」のことです。HTMLを変更せずにCSSだけで内容を追加できる強力な機能です。

**主な擬似要素:**
- **::before** - 要素の中身の前に何かを追加
- **::after** - 要素の中身の後に何かを追加

**基本的な使い方:**
```css
.example::before {
  content: "★"; /* 必須プロパティ。挿入する内容を指定 */
  color: red;    /* 通常の要素と同様にスタイリングできる */
}

.example::after {
  content: "☆";
  margin-left: 5px;
}
```

**実用例（アコーディオンメニューの+/-アイコン）:**
```css
.accordion-header::after {
  content: '+';   /* + 記号を挿入 */
  float: right;   /* 右側に配置 */
}

/* アクティブ状態では - 記号に変更 */
.accordion-header.active::after {
  content: '-';
}
```

**擬似要素を使うメリット:**
1. HTMLをシンプルに保てる（装飾目的のタグが減る）
2. JavaScriptを使わずにデザイン的な効果が得られる
3. 内容とデザインの分離がしやすくなる

#### marginプロパティの詳細

`margin`プロパティは要素の外側の余白（マージン）を設定するためのCSSプロパティです。

**値の指定方法:**

1. **一括指定**
   - `margin: 10px;` - 上下左右すべての余白を10pxに設定

2. **方向別の指定**
   - `margin-top`, `margin-right`, `margin-bottom`, `margin-left` - 各方向の余白を個別に指定

3. **省略記法（ショートハンド）**
   - `margin: 上 右 下 左;` - 時計回りで4つの値を指定
   - `margin: 上下 左右;` - 2つの値を指定（上下共通、左右共通）
   - `margin: 上 左右 下;` - 3つの値を指定（左右は共通）

**特別な値:**

1. **`auto`** - ブラウザによる自動計算
   - `margin: 0 auto;` - 上下マージンは0、左右マージンは自動計算により中央揃えを実現
   - 要素に幅（width）が設定されている場合に有効
   - ブロックレベル要素の水平中央配置に広く使用される
   - `<div>`, `<p>`, `<section>`などの要素を中央揃えにする際に便利

2. **負の値** - 要素を通常の配置位置から反対方向に移動させる
   - `margin-top: -20px;` - 要素を上方向に20px移動

**使用例と実践的なパターン:**

```css
/* コンテンツを中央揃えにするコンテナ */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto; /* 上下余白なし、左右自動で中央揃え */
}

/* カードデザインの余白設定 */
.card {
  margin: 20px; /* 全方向に20pxの余白 */
}

/* 段落間の間隔設定 */
p {
  margin: 0 0 1em 0; /* 上:0、右:0、下:1em、左:0 */
}
```

**注意点:**

- 複数要素間のマージンは「マージンの相殺（Margin Collapse）」が発生することがある（上下方向のみ）
- 特に垂直方向のレイアウトでは、隣接する要素同士のマージンは大きい方の値が採用される
- インライン要素には左右のマージンのみ適用され、上下のマージンは無視される

#### max-widthプロパティの詳細

`max-width`プロパティは要素の最大幅を制限するためのCSSプロパティです。要素は通常、親要素や内容に基づいて幅が決まりますが、`max-width`を設定すると指定した値以上に広がらなくなります。

**主な特徴と使い方:**

1. **レスポンシブデザインでの活用**
   - 大きな画面では幅を制限し、小さな画面では`width: 100%`と組み合わせて画面幅に合わせる
   - `max-width: 1200px;` - 画面が1200pxより広くても、要素は1200px以上に広がらない
   - `width: 100%;` と組み合わせると、小さな画面では画面いっぱいに、大きな画面では制限された幅で表示

2. **コンテンツの読みやすさの向上**
   - テキストコンテンツは行の長さが適切な範囲内（約50〜75文字）だと読みやすい
   - `max-width: 800px;` - 本文コンテナなどに設定し、行の長さを適切に保つ

3. **メディア要素の制御**
   - 画像やビデオが親要素からはみ出すのを防ぐ
   - `max-width: 100%;` - 画像やビデオを親要素より大きくならないように制限（レスポンシブイメージの基本テクニック）

**実用的な使用例:**

```css
/* レスポンシブなメインコンテナ */
.main-container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* 読みやすい本文エリア */
.article-content {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

/* レスポンシブな画像 */
img {
  max-width: 100%;
  height: auto;
}
```

**max-widthとwidthの違い:**

- `width` - 要素の固定幅を設定
- `max-width` - 要素が広がる最大値を制限するが、画面が小さくなると自動的に縮小

**他の関連プロパティ:**

- `min-width` - 要素の最小幅を設定
- `width` - 要素の幅を設定
- `max-height` - 要素の最大高さを設定
- `min-height` - 要素の最小高さを設定

**レスポンシブデザインでの典型的なパターン:**

```css
.container {
  width: 100%;      /* 小さい画面では画面幅いっぱいに広がる */
  max-width: 500px; /* 大きい画面では500pxを超えない */
  margin: 0 auto;   /* 中央揃え */
}
```

**このパターンの効果:**
- モバイル画面ではコンテナが画面幅いっぱいに表示される
- 画面が広くなるにつれてコンテナも広がるが、500pxを超えることはない
- 画面幅が500pxを超えると、コンテナは中央に配置される

**ポイント:**
- レスポンシブデザインの基本テクニック
- 異なる画面サイズでの一貫したユーザー体験を提供
- モバイルファーストの設計アプローチと相性が良い

#### overflow: hidden
ボックスからはみ出た内容を非表示にするプロパティ。
- アコーディオンメニューでは閉じた時に内容を完全に隠す
- メニューの開閉アニメーションをきれいに見せるために必要
- 値：visible（表示）、hidden（非表示）、scroll（常にスクロール）、auto（必要時スクロール）

#### リセットスタイル
ブラウザの標準スタイル設定をリセットするためのCSSコード。
- `margin: 0;` - すべての余白をゼロに
- `padding: 0;` - すべての内部余白をゼロに
- `box-sizing: border-box;` - ボーダーとパディングを幅と高さに含める

#### フォントフォールバック
`font-family: 'Helvetica Neue', Arial, sans-serif;`
- 左から順に適用を試みる（最初がなければ次を使用）
- 最後は必ずジェネリックファミリー（sans-serif等）を指定

#### Flexboxレイアウト
要素を柔軟に配置・整列させるための仕組み。
- `display: flex;` - フレックスボックスレイアウト
- `justify-content: center;` - 水平方向の配置
- `align-items: center;` - 垂直方向の配置
- `flex-direction: row/column;` - 並ぶ方向

### displayプロパティの詳細

`display`プロパティはHTML要素の表示方法を指定する最も基本的なCSSプロパティです。

#### 主な値と効果:

1. **`display: block`**
   - 要素が1行全体を占有する
   - 幅と高さを指定可能
   - `<div>`, `<p>`, `<h1>`などはデフォルトでblock
   - 前後に自動的に改行が入る

2. **`display: inline`**
   - テキストの流れに沿って表示される
   - 幅と高さを直接指定できない
   - `<span>`, `<a>`, `<strong>`などはデフォルトでinline
   - 改行なしで横に並ぶ

3. **`display: inline-block`**
   - inlineとblockの特性を組み合わせたもの
   - 横に並ぶが、幅と高さを指定できる
   - フォームの要素などによく使われる

4. **`display: none`**
   - 要素を完全に非表示にする
   - レイアウトにも影響しない（スペースも占有しない）
   - JavaScriptで動的に表示/非表示の切り替えに使用

5. **`display: flex`**
   - 要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）を柔軟にレイアウト可能
   - 一次元のレイアウト（横または縦の一方向）に最適
   - モバイルフレンドリーなレスポンシブデザインに適している

6. **`display: grid`**
   - 要素をグリッドコンテナに変換する
   - 行と列の二次元レイアウトを実現
   - 複雑なレイアウトを簡潔に記述可能
   - グリッドラインに基づいた正確な配置が可能

7. **`display: table`系**
   - HTMLのテーブル要素と同様の表示形式
   - `table`, `table-row`, `table-cell`などの値がある
   - 表形式のレイアウトを実現できるが、現在はflexやgridの利用が推奨

### align-itemsプロパティの詳細

`align-items`プロパティはFlexboxとGridレイアウトにおいて、コンテナ内の子要素をクロスアクシス（交差軸）上でどのように配置するかを指定します。Flexboxのデフォルト設定でクロスアクシスは縦方向（垂直方向）です。

#### 主な値と効果:

1. **`align-items: stretch`** (デフォルト値)
   - 子要素をコンテナの高さいっぱいに引き伸ばす
   - 子要素の高さが明示的に指定されていない場合のみ有効
   - サイドバーとメインコンテンツを同じ高さにするのに便利

2. **`align-items: flex-start`**
   - 子要素をクロスアクシスの開始位置（上端）に配置
   - 異なる高さの要素が上端で揃う
   - ヘッダーなどのトップに揃えたい場合に使用

3. **`align-items: flex-end`**
   - 子要素をクロスアクシスの終了位置（下端）に配置
   - 異なる高さの要素が下端で揃う
   - フッターなどの下部に揃えたい場合に使用

4. **`align-items: center`**
   - 子要素をクロスアクシスの中央に配置
   - 垂直方向の中央揃えを実現
   - ナビゲーションバーやモーダルウィンドウの中央配置に最適

5. **`align-items: baseline`**
   - 子要素のテキストのベースライン（文字の下線）で揃える
   - 異なるフォントサイズのテキストを綺麗に整列させるのに有効
   - タイポグラフィを重視するデザインで役立つ

**使用例:**

```css
/* 縦方向に中央揃えのナビゲーションバー */
.navbar {
  display: flex;
  height: 80px;
  align-items: center;
}

/* カードの内容を上部に揃える */
.card-container {
  display: flex;
  align-items: flex-start;
}

/* 全ての子要素を同じ高さにする */
.sidebar {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
```

**ポイント:**
- `flex-direction: column`を使用すると、メインアクシスと交差アクシスが入れ替わるため、`align-items`の効果も横方向に変わる
- Grid内での`align-items`はグリッドセル内の要素の配置を制御する
- `align-content`プロパティと混同しないこと（`align-content`は複数行にわたるフレックスアイテム全体の配置を制御）

### よく使われるFlexboxの組み合わせパターン

```css
.container {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
```

**詳細説明**:

1. **`display: flex`**
   - 対象の要素をフレックスコンテナに変換する
   - 子要素（フレックスアイテム）は初期設定で横並びになる
   - フレックスアイテムは自動的に伸縮し、親コンテナの領域に合わせて調整される
   - ブロック要素でもインライン要素でも適用可能

2. **`justify-content: space-between`**
   - メインアクシス（横方向）に沿った配置を指定
   - `space-between`は最初の要素を左端、最後の要素を右端に配置し、残りの要素を均等に分散
   - 子要素間の空白が均等になるよう自動調整される
   - 他の値: `flex-start`（左揃え）、`flex-end`（右揃え）、`center`（中央揃え）、`space-around`（周囲の余白均等）など

3. **`align-items: center`**
   - クロスアクシス（縦方向）に沿った配置を指定
   - `center`は子要素を縦方向の中央に配置
   - コンテナの高さより子要素の高さが小さい場合に、その効果が顕著に表れる
   - 他の値: `flex-start`（上揃え）、`flex-end`（下揃え）、`stretch`（親に合わせて伸縮）、`baseline`（ベースラインで揃える）

**このパターンの一般的な使用例**:
- ナビゲーションバー: ロゴを左、メニューを右に配置
- アコーディオンヘッダー: タイトルを左、開閉アイコンを右に配置
- カード内のフッター: 「詳細」ボタンを左、「いいね」ボタンを右に配置
- フォーム要素: ラベルを左、入力フィールドを右に配置

**ポイント**:
- 直感的で簡単に両端揃えと垂直中央揃えが実現できる
- レスポンシブデザインと相性が良い
- 従来のfloatやpositionを使った複雑なレイアウトよりもはるかに簡潔に記述できる
- ブラウザ互換性が高い（IE11以降、他の主要ブラウザは全て対応）

#### CSSの優先順位
1. 詳細度が高いセレクタが優先（インラインスタイル > ID > クラス > 要素）
2. 同じ詳細度なら後に書かれたスタイルが優先
3. !important指定は最優先（使用は避ける）

#### パディング指定
- 個別：`padding-top/right/bottom/left`
- 4値：`padding: 上 右 下 左`（時計回り）
- 3値：`padding: 上 右左 下`
- 2値：`padding: 上下 右左`
- 1値：`padding: 全方向`

### width設定のポイント

#### 基本的な考え方
1. **コンテンツに適した幅を選ぶ**
   - テキスト中心なら600〜700px程度（日本語20〜40文字が読みやすい）
   - 画像やリッチコンテンツなら必要に応じて広く

2. **レスポンシブデザインを考慮**
   - モバイル：画面幅の90〜100%
   - デスクトップ：最大幅（max-width）を設定

3. **基本的な設定方法**
   ```css
   .element {
     width: 90%;          /* 親要素の90% */
     max-width: 700px;    /* 最大幅を制限 */
     margin: 0 auto;      /* 中央揃え */
   }
   ```

#### 実用的なテクニック
- **コンテナ要素**には`max-width`で上限を設定
- **中身の要素**には`width: 100%`で親に合わせる
- `box-sizing: border-box`を使うとpadding/borderを含めた幅指定ができる

#### 注意点
- 幅が広すぎると行長が長くなり読みにくい
- 狭すぎると改行が多くなり不自然
- ユーザーの視線移動と画面サイズを考慮する

### 内部CSSの配置

HTMLファイル内で`<style>`タグを使って直接CSSコードを記述する場合、適切な配置場所は`<head>`タグの中で、特に終了直前が推奨されます。

**正しい配置順序:**
1. 文字コード設定: `<meta charset="UTF-8">`
2. ビューポート設定: `<meta name="viewport">`
3. タイトル情報: `<title>`
4. 外部CSSファイル: `<link rel="stylesheet">`
5. 内部CSS: `<style>` タグ

**コード例:**
```html
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ページタイトル</title>
  <link rel="stylesheet" href="external.css">
  <style>
    /* 内部CSS */
    body {
      font-family: sans-serif;
    }
    .container {
      margin: 0 auto;
    }
  </style>
</head>
```

**ポイント:**
- 基本情報（文字コードなど）を先に読み込んでから、スタイル情報を読み込む
- 外部CSSファイルを先に読み込み、内部CSSで上書きや調整ができるようにする
- 優先順位の関係上、同じセレクタの場合は後に記述されたスタイルが適用される

### インラインスタイル

HTMLの要素に直接`style`属性としてCSSを記述する方法です。

**基本構文:**
```html
<要素名 style="プロパティ1: 値1; プロパティ2: 値2;">コンテンツ</要素名>
```

**実例:**
```html
<body style="max-width: 800px; margin: 0 auto; padding: 20px; font-family: sans-serif;">
```

**特徴:**
- その要素だけに適用されるスタイルを定義できる
- 他のCSSスタイル（内部CSSや外部CSS）よりも優先度が高い
- HTMLとCSSが混在するため、コードの管理が難しくなることがある
- 同じスタイルを複数の要素に適用したい場合は非効率

**使い分け:**
- 1回限りの特別なスタイル適用に適している
- プロトタイプ作成や簡単なデモページに便利
- 大規模サイトでは保守性の観点から避けるべき
- JavaScriptでスタイルを動的に変更する場合にも使用される

**CSS適用方法の比較:**
1. インラインスタイル: 個別要素に直接記述（優先度最高）
2. 内部CSS: ページ内の複数要素に適用（`<head>`内の`<style>`タグ）
3. 外部CSS: 複数ページに適用（別ファイルを`<link>`で読み込み）

### CSSセレクタの種類

#### 要素セレクタとクラスセレクタの違い

CSSでは様々な方法で装飾対象を指定できますが、主に以下の2種類のセレクタが基本となります：

**要素セレクタ**
- HTMLタグを直接指定するセレクタ
- ピリオド（.）は付けません
- 例：`body { }`, `footer { }`, `h1 { }`
- 該当するHTML要素全てにスタイルが適用されます
- `body { background-color: white; }` はページ全体の背景色を白に設定

**クラスセレクタ**
- class属性を持つ要素を指定するセレクタ
- ピリオド（.）を先頭に付ける必要があります
- 例：`.main-container { }`, `.accordion-item { }`
- 特定のクラス名を持つ要素のみにスタイルが適用されます
- `.active { color: red; }` は`class="active"`を持つ要素のテキストを赤色に設定

**実践的な使い方：**
```css
/* 要素セレクタ - 全てのh1要素に適用 */
h1 {
  font-size: 24px;
  color: #333;
}

/* クラスセレクタ - class="highlight"を持つ全ての要素に適用 */
.highlight {
  background-color: yellow;
  padding: 5px;
}

/* 要素とクラスの組み合わせ - class="special"を持つh2要素のみに適用 */
h2.special {
  border-bottom: 2px solid blue;
}
```

**セレクタ選択の基準：**
- 全てのページ要素に共通スタイルを適用する場合 → 要素セレクタ
- 特定の要素群だけに限定したスタイルを適用する場合 → クラスセレクタ
- 細かく制御したい場合は、クラスセレクタの方が一般的に適しています

## 【JavaScript関連】

### アコーディオンメニューの開閉制御
```javascript
// アコーディオンメニュー制御
accordionHeader.addEventListener('click', function() {
    // コンテンツ部分を取得
    const content = this.nextElementSibling;
    
    // 開閉状態を切り替え
    if (content.style.maxHeight) {
        content.style.maxHeight = null; // 閉じる
    } else {
        content.style.maxHeight = content.scrollHeight + "px"; // 開く
    }
});
```

**重要なポイント**：
- `maxHeight`プロパティで高さを動的に制御
- `scrollHeight`で要素の実際の高さを取得
- CSSの`overflow: hidden`と組み合わせて使用

### イベント駆動型プログラミング

**JavaScriptのイベント概念**

JavaScriptでは「イベント」は、ウェブページやブラウザ上で発生する様々な「出来事」や「アクション」を指します。イベント駆動型プログラミングとは、これらのイベントに対して処理を定義するプログラミングスタイルです。

**主なイベントの種類：**

1. **ユーザーアクション系イベント:**
   - **クリックイベント**: ボタンやリンクがクリックされたとき
   - **マウスオーバーイベント**: マウスが要素の上に乗ったとき
   - **マウスアウトイベント**: マウスが要素から離れたとき
   - **キーダウンイベント**: キーボードのキーが押されたとき
   - **キーアップイベント**: キーボードのキーが離されたとき
   - **フォーカスイベント**: 入力フィールドなどにフォーカスが当たったとき

2. **ドキュメント系イベント:**
   - **ロードイベント**: ページが完全に読み込まれたとき
   - **DOMContentLoadedイベント**: HTMLドキュメントの読み込みと解析が完了したとき
   - **リサイズイベント**: ブラウザのウィンドウサイズが変更されたとき
   - **スクロールイベント**: ページがスクロールされたとき

3. **フォーム系イベント:**
   - **サブミットイベント**: フォームが送信されたとき
   - **チェンジイベント**: 入力内容が変更されたとき
   - **インプットイベント**: 入力フィールドの値が変更されたとき

**イベントリスナーの基本構文:**

```javascript
要素.addEventListener('イベント名', function() {
  // イベント発生時に実行する処理
});
```

**実際の例（アコーディオンメニュー）:**

```javascript
// ヘッダー要素を取得
const header = document.querySelector('.accordion-header');

// クリックイベントのリスナーを追加
header.addEventListener('click', function() {
  // ヘッダーがクリックされたときの処理
  const content = this.nextElementSibling;
  
  // コンテンツの表示/非表示を切り替え
  if (content.style.display === 'none') {
    content.style.display = 'block';
  } else {
    content.style.display = 'none';
  }
});
```

**重要ポイント:**
- イベントリスナーは「何かが起きたら〇〇する」という形で処理を定義する
- 一つの要素に複数のイベントリスナーを設定できる
- 同じイベントに対して複数の処理を設定することも可能
- イベントはHTMLが構築された後に登録するのが一般的（bodyタグの最後にJavaScriptを配置する理由）

## 【サジェスト機能の使い方】
### 基本的な使い方
- 文字を入力すると自動的に候補が表示される
- 候補の選択方法：
  - `Tab`キーで確定（最優先）
  - 矢印キー（↑↓）で選択し、`Enter`キーで確定
  - マウスでクリックして選択

### 手動で候補を表示する方法
- Mac: `Command + Space`
- Windows/Linux: `Ctrl + Space`

## 【HTMLのショートカット入力】

### Emmetショートカット
- `!` + `Tab` - HTML5の基本構造を自動生成
- `html:5` + `Tab` - 同じく基本構造生成

### index.htmlについて
- Webサーバーのデフォルトファイル名として認識される
- URLでディレクトリ名のみを指定した場合（例：`example.com/folder/`）、自動的に`index.html`が表示される
- フォルダのトップページ・メインページとして使われる慣習的な命名規則

## Git・GitHub関連

### 基本用語
- リポジトリ：プロジェクトの保存場所。変更履歴も保存される賢いフォルダ
- プッシュ：ローカルのファイルをGitHubのリポジトリにアップロードすること
- ステージング：変更したファイルをコミット前に準備するプロセス。次のコミットに含めるファイルを指定する作業

### ステージングについて
- 目的：どのファイルの変更をコミットに含めるかを選択すること
- 実行方法：`git add <ファイル名>`

## JavaScriptファイルの読み込み方法
_追加日: 2025年4月9日_

### HTMLからJavaScriptファイルを読み込む基本

```html
<!-- JavaScriptファイルの読み込み -->
<script src="script.js"></script>
```

### 読み込み位置による違い

1. **`</body>`タグの直前（推奨）**
   - ページの読み込みが完了した後にJavaScriptが実行される
   - DOM要素が全て構築された状態でJavaScriptが実行されるため安全
   - ページの表示速度が向上する

   ```html
   <body>
     <!-- HTMLコンテンツ -->
     
     <script src="script.js"></script>
   </body>
   ```

2. **`<head>`タグ内**
   - HTMLが読み込まれる前にJavaScriptが実行される可能性がある
   - DOM要素にアクセスする場合、`DOMContentLoaded`イベントや`window.onload`を使用する必要がある
   
   ```html
   <head>
     <script src="script.js"></script>
     <!-- または、deferを指定して実行タイミングを遅らせる -->
     <script src="script.js" defer></script>
   </head>
   ```

### 属性オプション

- **`defer`属性**: HTMLの解析が完了した後に実行される（`<head>`内で使用する際に有用）
  ```html
  <script src="script.js" defer></script>
  ```

- **`async`属性**: ファイルのダウンロードが完了次第実行される（DOM操作を行わないスクリプトに適している）
  ```html
  <script src="script.js" async></script>
  ```

### 相対パスと絶対パス

1. **同じディレクトリのファイル**:
   ```html
   <script src="script.js"></script>
   ```

2. **サブディレクトリのファイル**:
   ```html
   <script src="js/script.js"></script>
   ```

3. **親ディレクトリのファイル**:
   ```html
   <script src="../script.js"></script>
   ```

4. **絶対パス（同じドメイン内）**:
   ```html
   <script src="/js/script.js"></script>
   ```

5. **外部URL**:
   ```html
   <script src="https://example.com/script.js"></script>
   ```

## 【2025/04/16】JavaScript基本構文とよくあるエラー

### 文字列操作で気をつけること
- JavaScriptでの文字列連結方法（2種類）：
  1. 「+」演算子による連結: `"文字列" + 変数 + "文字列"`
  2. テンプレートリテラルによる埋め込み: `` `文字列${変数}文字列` ``（バッククォート使用）
- **全角記号と半角記号の区別**：
  - 正しい（半角）: `"りんごの値段は" + (個数 * 100) + "円です"`
  - 誤り（全角）: `"りんごの値段は"＋（個数 * 100）＋"円です"`

### 関数定義と呼び出しのエラー
- 関数名と呼び出し名は完全に一致させる必要がある
  - 定義: `function 大きい数字(a, b) {...}`
  - 正しい呼び出し: `大きい数字(10, 5)`
  - 誤った呼び出し: `大きい方(10, 5)` → エラー発生

### 条件分岐の実装
- if文での条件式は論理的に正しく記述する：
  ```javascript
  // 正しい条件分岐（両方のケースを考慮）
  if (a > b) {
    return a + "の方が大きいです";
  } else {
    return b + "の方が大きいです"; 
  }
  
  // 誤った条件分岐（両方同じ条件）
  if (a < b) {
    return a + "の方が大きいです";
  } else if (a < b) {
    return b + "の方が大きいです";
  }
  ```

### 構文エラーのデバッグ手順
1. コンソールでエラーメッセージを確認
2. 行番号と具体的なエラー内容を特定
3. 記号（括弧、引用符、セミコロンなど）が半角か確認
4. 変数名と関数名が一致しているか確認
5. 文字列内の変数が正しく埋め込まれているか確認

### テンプレートリテラルの活用
```javascript
// 名前と年齢を表示する関数
function 自己紹介(名前, 年齢) {
  // テンプレートリテラルを使用（バッククォート）
  return `私の名前は${名前}です。${年齢}歳です。`;
}
```
